<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Prueba de Llamadas ElevenLabs - Modern</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f8f9fa;
        color: #333;
      }
      .app-container {
        max-width: 900px;
        margin: 0 auto;
        padding: 30px 15px;
      }
      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 30px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .card {
        border: none;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
        transition: transform 0.3s;
        margin-bottom: 20px;
      }
      .card:hover {
        transform: translateY(-5px);
      }
      .form-control {
        border-radius: 8px;
        padding: 12px;
      }
      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        border-radius: 8px;
        padding: 10px 25px;
        font-weight: 600;
        transition: all 0.3s;
      }
      .btn-primary:hover:not(:disabled) {
        background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }
       .btn-danger {
        border-radius: 8px;
        padding: 10px 25px;
        font-weight: 600;
      }
      #logs {
        background: #1a1a1a;
        color: #00ff7f;
        padding: 15px;
        border-radius: 10px;
        height: 300px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        white-space: pre-wrap;
        word-wrap: break-word;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
      }
      .chat-container {
        background: #fff;
        border-radius: 10px;
        max-height: 300px;
        overflow-y: auto;
        padding: 10px;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
      }
      .chat-message {
        margin: 10px;
        padding: 10px 15px;
        border-radius: 18px;
        max-width: 75%;
        position: relative;
        display: flex;
        flex-direction: column;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }
      .chat-message.server {
        background-color: #e9f5ff;
        color: #333;
        align-self: flex-start;
        margin-right: auto;
        border-bottom-left-radius: 5px;
      }
      .chat-message.client {
        background-color: #dcf8c6;
        color: #333;
        align-self: flex-end;
        margin-left: auto;
        border-bottom-right-radius: 5px;
      }
       .section-title {
        color: #555;
        margin: 30px 0 15px;
        font-weight: 600;
        position: relative;
        padding-left: 15px;
        display: flex;
        align-items: center;
      }
      .section-title::before {
        content: '';
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 5px;
        height: 25px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 5px;
      }
       .status-badge {
        font-size: 0.9rem;
        padding: 0.4em 0.8em;
        border-radius: 15px;
        margin-left: 15px;
        font-weight: 600;
        letter-spacing: 0.5px;
      }
      .status-idle { background-color: #6c757d; color: white; }
      .status-initiating { background-color: #ffc107; color: black; }
      .status-in_progress { background-color: #0d6efd; color: white; }
      .status-terminating { background-color: #fd7e14; color: white; }
      .status-completed { background-color: #198754; color: white; }
      .status-failed { background-color: #dc3545; color: white; }
      .status-interrupted { background-color: #ffc107; color: black; } /* Keep visual style for interrupted */


      .metrics-section {
        background-color: #e9ecef;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
      }
       .metrics-section h5 {
        margin-bottom: 15px;
        color: #495057;
      }
       .metrics-section p {
        margin-bottom: 5px;
        font-size: 0.95rem;
      }
       .metrics-section strong {
        color: #343a40;
      }
      .ws-status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }
      .ws-status-indicator.online {
        background-color: #28a745;
        box-shadow: 0 0 5px #28a745;
      }
      .ws-status-indicator.offline {
        background-color: #dc3545;
      }
      .ws-status-text {
        font-size: 0.9rem;
        color: #666;
      }
      .call-controls {
          margin-top: 15px;
          gap: 0.5rem;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useEffect, useRef, useCallback } = React;

      // Mapping states to user-friendly text and CSS classes
      const callStatusInfo = {
        idle: { text: 'Inactivo', cssClass: 'status-idle' },
        initiating: { text: 'Iniciando...', cssClass: 'status-initiating' },
        in_progress: { text: 'En Progreso', cssClass: 'status-in_progress' },
        terminating: { text: 'Terminando...', cssClass: 'status-terminating' },
        completed: { text: 'Completada', cssClass: 'status-completed' },
        failed: { text: 'Fallida', cssClass: 'status-failed' },
        interrupted: { text: 'Interrumpida', cssClass: 'status-failed' } // Added interrupted state mapping
      };

      function App() {
        const [userName, setUserName] = useState('');
        const [toNumber, setToNumber] = useState('');
        const [callResponse, setCallResponse] = useState(null);
        const [logs, setLogs] = useState([]);
        const [chatMessages, setChatMessages] = useState([]);
        const [isWsConnected, setIsWsConnected] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const [isHangupLoading, setIsHangupLoading] = useState(false);
        const [currentCallSid, setCurrentCallSid] = useState(null);
        const [callState, setCallState] = useState('idle');
        const [lastMetrics, setLastMetrics] = useState(null);
        // Removed isMonitoringActive state

        // Removed audio related refs: audioContext, audioQueue, isPlaying, sourceNodeRef

        const logsRef = useRef(null);
        const chatRef = useRef(null);
        const wsRef = useRef(null);

        const addLog = useCallback((message) => {
          const timestamp = new Date().toLocaleTimeString();
          // Limit logs shown in UI for performance
          setLogs(prevLogs => [`[${timestamp}] ${message}`, ...prevLogs].slice(0, 200));
        }, []);

        // Removed: getAudioContext, playAudio, enqueueAudio, stopPlayback

        const connectWebSocket = useCallback(() => {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}/logs-websocket`;

          if (wsRef.current && (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING)) {
            return;
          }

          wsRef.current = new WebSocket(wsUrl);

          wsRef.current.onopen = () => {
            setIsWsConnected(true);
            addLog("[INFO] Conexión WebSocket establecida con el servidor.");
          };

          wsRef.current.onmessage = (event) => {
            const message = event.data;
            let parsedMessage = null;

            try {
              parsedMessage = JSON.parse(message);
            } catch (e) {
              addLog(message);
              // Simpler state update based on logs
              if (message.includes("[Twilio] Stream iniciado")) {
                  setCallState(prevState => prevState === 'initiating' ? 'in_progress' : prevState);
              }
            }

            if (parsedMessage) {
              // Removed audio message handling
              if (parsedMessage.type === 'metrics' && parsedMessage.data) {
                addLog(`[METRICS] Métricas recibidas: ${JSON.stringify(parsedMessage.data)}`);
                setLastMetrics(parsedMessage.data);
                setCallState('completed');
                setCurrentCallSid(null);
              } else if (parsedMessage.type === 'call_status' && parsedMessage.status) {
                 addLog(`[STATUS] Actualización de estado: ${parsedMessage.status}`);
                 const newStatus = parsedMessage.status;
                 setCallState(newStatus);
                 // Clear SID only on final states signaled by backend
                 if (newStatus === 'completed' || newStatus === 'failed') {
                    setCurrentCallSid(null);
                 }
              } else if (parsedMessage.type === 'transcript') {
                  if(parsedMessage.source === 'user') {
                      addChatMessage(parsedMessage.text, 'client');
                      addLog(`[TRANSCRIPT] Usuario: ${parsedMessage.text}`);
                  } else if (parsedMessage.source === 'agent') {
                      addChatMessage(parsedMessage.text, 'server');
                      addLog(`[TRANSCRIPT] Agente: ${parsedMessage.text}`);
                  }
              }
               else if (parsedMessage.type !== 'audio') { // Ignore audio messages silently now
                 addLog(`[JSON] Mensaje estructurado recibido: ${message}`);
              }
            } else {
               // Fallback for legacy transcript logs
               if (message.includes("[Twilio] Respuesta del agente:")) {
                   const agentMessage = message.split("[Twilio] Respuesta del agente:")[1].trim();
                   addChatMessage(agentMessage, 'server');
               } else if (message.includes("[Twilio] Transcripción del usuario:")) {
                   const userMessage = message.split("[Twilio] Transcripción del usuario:")[1].trim();
                   addChatMessage(userMessage, 'client');
               }
            }
          };

          // Simplified onclose handler
          wsRef.current.onclose = () => {
            setIsWsConnected(false);
            addLog("[INFO] Conexión WebSocket cerrada.");
            // Update state cautiously only if call seemed active
            setCallState(prevState => {
                if (prevState === 'in_progress' || prevState === 'terminating') {
                    addLog("[WARN] WS cerrado inesperadamente. Marcando como Interrumpida.");
                    return 'interrupted'; // Still allow hangup attempts if needed
                }
                return prevState; // Keep completed/failed/idle states
            });
            // Don't clear currentCallSid - allow hangup attempt if interrupted
            // Removed stopPlayback call
            setTimeout(connectWebSocket, 5000); // Attempt reconnect
          };

          wsRef.current.onerror = (error) => {
            setIsWsConnected(false);
            addLog("[ERROR] Error en WebSocket. Intentando reconectar...");
            console.error("WebSocket error:", error);
          };

        // Removed dependencies related to audio playback
        }, [addLog]);


        useEffect(() => {
          connectWebSocket();
          // Removed audio context cleanup
          return () => {
            if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
              wsRef.current.close();
            }
          };
        }, [connectWebSocket]);


        useEffect(() => {
          if (logsRef.current) {
             logsRef.current.scrollTop = 0; // Scroll to top for latest logs
          }
        }, [logs]);


        useEffect(() => {
          if (chatRef.current) {
            chatRef.current.scrollTop = chatRef.current.scrollHeight;
          }
        }, [chatMessages]);

        const addChatMessage = (content, type) => {
          setChatMessages(prev => [...prev, { content, type }]);
        };

        const handleStartCall = async (e) => {
          e.preventDefault();
          setIsLoading(true);
          setCallResponse(null);
          setLastMetrics(null);
          setChatMessages([]);
          setLogs([]);
          setCallState('initiating');
          setCurrentCallSid(null);
          // Removed stopPlayback call

          addLog(`[INFO] Iniciando llamada a ${toNumber || 'número predeterminado'} para ${userName}...`);

          // Removed AudioContext init/resume logic

          try {
            const response = await fetch('/outbound-call', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ nombre: userName, to_number: toNumber || undefined })
            });
            const data = await response.json();
            setCallResponse(data);
            if (response.ok && data.success && data.callSid) {
              setCurrentCallSid(data.callSid);
              addLog(`[INFO] Petición de llamada enviada. CallSid: ${data.callSid}`);
            } else { throw new Error(data.error || `HTTP ${response.status}`); }
          } catch (error) {
            console.error("Error starting call:", error);
            addLog(`[ERROR] Falló el inicio de la llamada: ${error.message}`);
            setCallResponse({ success: false, error: error.message });
            setCallState('failed');
            setCurrentCallSid(null);
          } finally { setIsLoading(false); }
        };

         const handleHangupCall = async () => {
            // Use the refined canHangup condition check
            const canHangup = !!currentCallSid && !['idle', 'completed', 'failed'].includes(callState);

            if (!canHangup) {
                 addLog(`[WARN] No se puede colgar. Estado: ${callState}, CallSid: ${currentCallSid || 'N/A'}`);
                 return;
            }

            setIsHangupLoading(true);
            // Set state to terminating *unless* it's already a final state
            setCallState(prevState => ['idle', 'completed', 'failed'].includes(prevState) ? prevState : 'terminating');
            addLog(`[INFO] Solicitando colgar llamada manualmente: ${currentCallSid}`);

            try {
                const response = await fetch('/hangup-call', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ callSid: currentCallSid })
                });
                const data = await response.json();
                if (response.ok && data.success) {
                    addLog(`[INFO] Solicitud de colgar enviada exitosamente para ${currentCallSid}. Esperando confirmación final.`);
                } else { throw new Error(data.error || `HTTP ${response.status}`); }
            } catch (error) {
                console.error("Error hanging up call:", error);
                addLog(`[ERROR] Falló la solicitud de colgar: ${error.message}`);
                // Revert state only if API failed and call wasn't already ended
                 setCallState(prevState => {
                     if (prevState === 'terminating') return 'in_progress'; // Or maybe 'interrupted'? Let's try in_progress
                     return prevState;
                 });
            } finally { setIsHangupLoading(false); }
         };

         // Removed toggleMonitoring function

         const currentStatusInfo = callStatusInfo[callState] || callStatusInfo.idle;
         // Removed canMonitor variable
         // Refined canHangup condition
         const canHangup = !!currentCallSid && !['idle', 'completed', 'failed'].includes(callState);

        return (
          <div className="app-container">
            <div className="header text-center">
              <h1><i className="fas fa-phone-alt me-2"></i> ElevenLabs - Prueba de Llamadas</h1>
              <p className="mb-0">Sistema de pruebas de llamadas automatizadas con IA</p>
            </div>

            <div className="d-flex align-items-center mb-3">
              <div className={`ws-status-indicator ${isWsConnected ? 'online' : 'offline'}`}></div>
              <span className="ws-status-text">{isWsConnected ? 'Conectado al servidor' : 'Desconectado del servidor'}</span>
               <div className="ms-auto"><strong>URL pública:</strong> <span id="publicUrl">{{publicUrl}}</span></div>
            </div>

            <div className="card">
              <div className="card-body">
                 <div className="d-flex justify-content-between align-items-center mb-3">
                     <h5 className="card-title mb-0"><i className="fas fa-headset me-2"></i> Nueva llamada</h5>
                     <span className={`badge ${currentStatusInfo.cssClass} status-badge`}>{currentStatusInfo.text}</span>
                 </div>

                <form id="callForm" onSubmit={handleStartCall}>
                  <div className="mb-3">
                    <label htmlFor="userName" className="form-label"><i className="fas fa-user me-2"></i>Nombre de la persona a llamar:</label>
                    <input type="text" className="form-control" id="userName" placeholder="Ingrese el nombre" value={userName} onChange={(e) => setUserName(e.target.value)} required disabled={isLoading || (callState !== 'idle' && callState !== 'completed' && callState !== 'failed' && callState !== 'interrupted')} />
                  </div>
                  <div className="mb-4">
                    <label htmlFor="toNumber" className="form-label"><i className="fas fa-phone me-2"></i>Número de teléfono (opcional):</label>
                    <input type="text" className="form-control" id="toNumber" placeholder="+541161728140" value={toNumber} onChange={(e) => setToNumber(e.target.value)} disabled={isLoading || (callState !== 'idle' && callState !== 'completed' && callState !== 'failed' && callState !== 'interrupted')} />
                    <div className="form-text">Se usará el número predeterminado si está vacío.</div>
                  </div>

                   {/* --- Removed Monitoring Button --- */}
                   <div className="call-controls d-grid gap-2 d-sm-flex justify-content-sm-center">
                     <button type="submit" className="btn btn-primary" disabled={isLoading || isHangupLoading || (callState !== 'idle' && callState !== 'completed' && callState !== 'failed' && callState !== 'interrupted')}>
                       {isLoading ? (<><span className="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span> Iniciando...</>) : (<><i className="fas fa-phone-alt me-2"></i> Iniciar Llamada</>)}
                     </button>
                     <button type="button" className="btn btn-danger" onClick={handleHangupCall} disabled={isHangupLoading || isLoading || !canHangup}>
                       {isHangupLoading ? (<><span className="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span> Colgando...</>) : (<><i className="fas fa-phone-slash me-2"></i> Colgar</>)}
                     </button>
                     {/* Monitoring button removed */}
                   </div>
                </form>
              </div>
            </div>

            {callResponse && (<div className={`alert ${callResponse.success ? 'alert-info' : 'alert-warning'} mt-3`} role="alert"><strong>Respuesta API:</strong> {callResponse.success ? `Éxito (SID: ${callResponse.callSid || 'N/A'})` : `Error: ${callResponse.error || 'Desconocido'}`}</div>)}

            {lastMetrics && (callState === 'completed' || callState === 'failed' || callState === 'interrupted') && (<div className="metrics-section"><h5><i className="fas fa-chart-bar me-2"></i>Métricas de la Última Llamada</h5><p><strong>Duración:</strong> {lastMetrics.duration != null ? `${lastMetrics.duration.toFixed(2)} segundos` : 'N/A'}</p><p><strong>Finalizada por:</strong> {lastMetrics.initiator || 'Desconocido'}</p><p><strong>Turnos de conversación (Agente):</strong> {lastMetrics.agentTurns != null ? lastMetrics.agentTurns : 'N/A'}</p><p><strong>Turnos de conversación (Usuario):</strong> {lastMetrics.userTurns != null ? lastMetrics.userTurns : 'N/A'}</p></div>)}

            <h3 className="section-title"><i className="fas fa-comments me-2"></i> Conversación Transcripta</h3>
            <div className="chat-container" ref={chatRef}>
              {chatMessages.length === 0 ? (<div className="text-center text-muted p-5"><i className="fas fa-comment-slash fa-3x mb-3 d-block"></i> La conversación aparecerá aquí.</div>) : (<div style={{ display: 'flex', flexDirection: 'column' }}>{chatMessages.map((msg, index) => (<div key={index} className={`chat-message ${msg.type}`}>{msg.content}</div>))}</div>)}
            </div>

            <h3 className="section-title"><i className="fas fa-terminal me-2"></i> Logs del servidor</h3>
            <div id="logs" ref={logsRef}>
              {logs.length === 0 ? (<span className="text-muted">Esperando logs...</span>) : (logs.map((log, index) => (<div key={index}>{log}</div>)))}
            </div>
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById('root'));
    </script>
  </body>
</html>