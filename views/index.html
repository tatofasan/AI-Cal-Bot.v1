<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prueba de Llamadas ElevenLabs</title>
  <!-- Incluir Tailwind CSS desde CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 font-sans antialiased">
  <!-- Header con indicador de llamada -->
  <header class="bg-blue-600 text-white p-4 shadow-md">
    <div class="max-w-3xl mx-auto flex items-center justify-between">
      <h1 class="text-2xl font-bold">ElevenLabs Call Bot</h1>
      <!-- Indicador de estado de llamada -->
      <div id="callStatus" class="flex items-center space-x-2">
        <span class="w-3 h-3 rounded-full bg-red-500" id="statusIndicator"></span>
        <span id="statusText">Sin conexión</span>
      </div>
    </div>
  </header>
  
  <main class="max-w-3xl mx-auto p-6">
    <form id="callForm" class="bg-white shadow-md rounded px-8 pt-6 pb-8 mb-6">
      <div class="mb-4">
        <label for="userName" class="block text-gray-700 text-sm font-bold mb-2">Nombre de la persona a llamar:</label>
        <input type="text" id="userName" placeholder="Ingrese el nombre" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
      </div>
      <div class="mb-4">
        <label for="toNumber" class="block text-gray-700 text-sm font-bold mb-2">Número de teléfono (opcional, se usará el predeterminado si está vacío):</label>
        <input type="text" id="toNumber" placeholder="+541161728140" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
      </div>
      <!-- Nuevo combobox para selección de voz -->
      <div class="mb-4">
        <label for="voiceSelected" class="block text-gray-700 text-sm font-bold mb-2">Seleccionar Voz:</label>
        <select id="voiceSelected" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
          <option value="random" data-nombre="Random" selected>Voz Aleatoria</option>
          <option value="15bJsujCI3tcDWeoZsQP" data-nombre="Ernesto Ferran">Ernesto Ferran</option>
          <option value="dXzxF8F6baTsuGSxeorB" data-nombre="Valeria Rodriguez">Valeria Rodriguez</option>
          <option value="ukupJ4zdf9bo1Py6MiO6" data-nombre="Bruno Fernandez">Beto</option>
          <option value="YExhVa4bZONzeingloMX" data-nombre="Juan Carlos Gutierrez">Juan Carlos</option>
          <option value="rEVYTKPqwSMhytFPayIb" data-nombre="Sandra Valenzuela">Sandra Entusiasta</option>
          <option value="B5TKeu06uYzJCV6Pss3g" data-nombre="Fernando Mansilla">Fernando</option>
          <option value="qHkrJuifPpn95wK3rm2A" data-nombre="Andrea Chamorro">Andrea Colombiana</option>
        </select>
      </div>
      <!-- Contenedor de controles en línea: botón unificado de llamar/cortar y botón de monitoreo -->
      <div class="flex justify-center space-x-4 mb-4">
        <!-- Botón unificado de llamar / cortar llamada -->
        <button id="callButton" type="button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
          <!-- Ícono Teléfono (inicialmente, para llamar) -->
          <svg id="callIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.518 4.556a1 1 0 01-.21.915L8.532 11.97a11.01 11.01 0 005.516 5.517l1.822-1.797a1 1 0 01.915-.21l4.556 1.518a1 1 0 01.684.949V19a2 2 0 01-2 2h-1" />
          </svg>
        </button>
        <!-- Botón de monitoreo de audio -->
        <button id="monitorAudioButton" type="button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
          <!-- Ícono Altavoz (activo por defecto) -->
          <svg id="monitorIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
              d="M11 5h2m-2 14h2m-2-7h2m6.586-3.586A2 2 0 0018 7H6a2 2 0 00-1.414.586L3 9v6l1.586 1.414A2 2 0 006 17h12a2 2 0 001.414-.586L21 15V9l-1.414-1.414z" />
          </svg>
        </button>
      </div>
    </form>

    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Conversación Transcrita</h2>
    <!-- Chat box (se mantiene al cortar, se limpia al iniciar una nueva llamada) -->
    <div class="chat-container bg-gray-100 p-4 rounded shadow mb-6" id="chatBox" style="max-height:300px; overflow-y:auto;"></div>

    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Logs del Servidor</h2>
    <div id="logs" class="bg-black text-green-400 p-4 rounded h-72 overflow-y-auto font-mono text-sm whitespace-pre-wrap"></div>
  </main>

  <!-- Toast para mostrar errores -->
  <div id="toast" class="fixed top-4 right-4 bg-red-500 text-white px-4 py-2 rounded shadow hidden"></div>

  <script>
    // Crear AudioContext para reproducir audio decodificado
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    // Variables para programar la reproducción independiente de bot y cliente
    let nextBotAudioTime = audioContext.currentTime;
    let nextClientAudioTime = audioContext.currentTime;
    // Arreglos para almacenar los nodos de audio activos
    let botAudioSources = [];
    let clientAudioSources = [];
    // Variable para almacenar el callSid de la llamada actual (null = no hay llamada activa)
    let currentCallSid = null;
    // Por defecto, el monitoreo está activado
    let isMonitoring = true;
    
    // Función para actualizar el ícono del botón de monitoreo según su estado
    function updateMonitorIcon() {
      const monitorIcon = document.getElementById('monitorIcon');
      if (isMonitoring) {
        monitorIcon.outerHTML = `<svg id="monitorIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M11 5h2m-2 14h2m-2-7h2m6.586-3.586A2 2 0 0018 7H6a2 2 0 00-1.414.586L3 9v6l1.586 1.414A2 2 0 006 17h12a2 2 0 001.414-.586L21 15V9l-1.414-1.414z" />
        </svg>`;
      } else {
        monitorIcon.outerHTML = `<svg id="monitorIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M11 5h2m-2 14h2m-2-7h2m6.586-3.586A2 2 0 0018 7H6a2 2 0 00-1.414.586L3 9v6l1.586 1.414A2 2 0 006 17h12a2 2 0 001.414-.586L21 15V9l-1.414-1.414z" />
          <line x1="3" y1="3" x2="21" y2="21" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>`;
      }
    }
    updateMonitorIcon();

    // Función para decodificar un byte μ-law a PCM lineal
    function muLawToLinear(u_val) {
      u_val = ~u_val & 0xFF;
      let t = ((u_val & 0x0F) << 3) + 0x84;
      t <<= (u_val >> 4) & 0x07;
      return (u_val & 0x80) ? (0x84 - t) : (t - 0x84);
    }

    // Función para decodificar audio μ-law
    function decodeMuLaw(base64Data) {
      const binaryString = atob(base64Data);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      const samples = new Float32Array(bytes.length);
      for (let i = 0; i < bytes.length; i++) {
        samples[i] = muLawToLinear(bytes[i]) / 32124;
      }
      return { samples, sampleRate: 8000 };
    }

    // Función para reproducir audio del bot y almacenar la fuente
    function playBotAudioChunk(base64Data) {
      const { samples, sampleRate } = decodeMuLaw(base64Data);
      const audioBuffer = audioContext.createBuffer(1, samples.length, sampleRate);
      audioBuffer.getChannelData(0).set(samples);
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);
      botAudioSources.push(source);
      source.onended = () => { botAudioSources = botAudioSources.filter(s => s !== source); };
      const now = audioContext.currentTime;
      if (nextBotAudioTime < now) nextBotAudioTime = now;
      source.start(nextBotAudioTime);
      nextBotAudioTime += audioBuffer.duration;
    }

    // Función para reproducir audio del cliente y almacenar la fuente
    function playClientAudioChunk(base64Data) {
      const { samples, sampleRate } = decodeMuLaw(base64Data);
      const audioBuffer = audioContext.createBuffer(1, samples.length, sampleRate);
      audioBuffer.getChannelData(0).set(samples);
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);
      clientAudioSources.push(source);
      source.onended = () => { clientAudioSources = clientAudioSources.filter(s => s !== source); };
      const now = audioContext.currentTime;
      if (nextClientAudioTime < now) nextClientAudioTime = now;
      source.start(nextClientAudioTime);
      nextClientAudioTime += audioBuffer.duration;
    }

    // Función para detener todos los audios pendientes y reiniciar tiempos
    function clearAudioQueues() {
      botAudioSources.forEach(source => { try { source.stop(); } catch(e) { console.error(e); } });
      clientAudioSources.forEach(source => { try { source.stop(); } catch(e) { console.error(e); } });
      botAudioSources = [];
      clientAudioSources = [];
      nextBotAudioTime = audioContext.currentTime;
      nextClientAudioTime = audioContext.currentTime;
      console.log("Audio queues cleared due to interruption or monitoring off.");
    }

    // Evento para el botón de monitoreo: al alternar, detener inmediatamente cualquier audio en curso
    document.getElementById('monitorAudioButton').addEventListener('click', () => {
      isMonitoring = !isMonitoring;
      updateMonitorIcon();
      clearAudioQueues();
    });

    // Evento unificado para el botón de llamar/cortar llamada
    document.getElementById('callButton').addEventListener('click', async () => {
      const callButton = document.getElementById('callButton');
      // Si no hay llamada activa, iniciar la llamada
      if (!currentCallSid) {
        // Limpiar transcript para una nueva llamada
        document.getElementById('chatBox').innerHTML = "";
        callButton.disabled = true;
        // Mostrar spinner mientras conecta
        callButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block animate-spin" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.518 4.556a1 1 0 01-.21.915L8.532 11.97a11.01 11.01 0 005.516 5.517l1.822-1.797a1 1 0 01.915-.21l4.556 1.518a1 1 0 01.684.949V19a2 2 0 01-2 2h-1" /></svg>';
        try {
          const userNameValue = document.getElementById('userName').value;
          const toNumberValue = document.getElementById('toNumber').value || null;
          const voiceSelect = document.getElementById('voiceSelected');
          const voiceIdValue = voiceSelect.value;
          const voiceNameValue = voiceSelect.options[voiceSelect.selectedIndex].getAttribute('data-nombre');
          const response = await fetch('/outbound-call', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_name: userNameValue, to_number: toNumberValue, voice_id: voiceIdValue, voice_name: voiceNameValue })
          });
          if (!response.ok) throw new Error("Error HTTP: " + response.status + " " + response.statusText);
          const result = await response.json();
          // Actualizar el botón para que ahora funcione como "colgar": cambiar a color rojo y mostrar ícono de corte
          currentCallSid = result.callSid;
          callButton.classList.remove("bg-green-500", "hover:bg-green-600");
          callButton.classList.add("bg-red-500", "hover:bg-red-600");
          callButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>';
          document.getElementById('statusIndicator').classList.replace('bg-red-500', 'bg-green-500');
          document.getElementById('statusText').textContent = 'Conectado';
        } catch (error) {
          console.error(error);
          callButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.518 4.556a1 1 0 01-.21.915L8.532 11.97a11.01 11.01 0 005.516 5.517l1.822-1.797a1 1 0 01.915-.21l4.556 1.518a1 1 0 01.684.949V19a2 2 0 01-2 2h-1" /></svg>';
          alert(error.toString());
        } finally {
          setTimeout(() => { callButton.disabled = false; }, 5000);
        }
      } else {
        // Si ya hay una llamada activa, al presionar se finaliza la llamada
        try {
          const response = await fetch('/end-call', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ callSid: currentCallSid })
          });
          if (!response.ok) throw new Error("Error al cortar la llamada");
          const result = await response.json();
          console.log("Llamada cortada:", result.message);
          clearAudioQueues();
          currentCallSid = null;
          // Actualizar botón: regresar a color verde y mostrar ícono de teléfono
          callButton.classList.remove("bg-red-500", "hover:bg-red-600");
          callButton.classList.add("bg-green-500", "hover:bg-green-600");
          callButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.518 4.556a1 1 0 01-.21.915L8.532 11.97a11.01 11.01 0 005.516 5.517l1.822-1.797a1 1 0 01.915-.21l4.556 1.518a1 1 0 01.684.949V19a2 2 0 01-2 2h-1" /></svg>';
          document.getElementById('statusIndicator').classList.replace('bg-green-500', 'bg-red-500');
          document.getElementById('statusText').textContent = 'Llamada cortada';
        } catch (error) {
          console.error("Error al cortar la llamada:", error);
          alert("Error al cortar la llamada.");
        }
      }
    });

    // WebSocket para recibir logs y audio
    const logsElement = document.getElementById('logs');
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const logsWs = new WebSocket(wsProtocol + '//' + window.location.host + '/logs-websocket');
    logsElement.innerHTML = '[INFO] Esperando conexión a logs...\n';

    logsWs.onopen = function() {
      logsElement.innerHTML += '[INFO] Conexión a logs establecida\n';
      const heartbeatInterval = setInterval(() => {
        if (logsWs.readyState === WebSocket.OPEN) { logsWs.send('heartbeat'); }
        else { clearInterval(heartbeatInterval); }
      }, 30000);
      logsWs.addEventListener('close', () => { clearInterval(heartbeatInterval); });
    };

    logsWs.onmessage = function(event) {
      let data;
      try { data = JSON.parse(event.data); }
      catch (e) { data = { type: "log", message: event.data }; }
      if (data.type === "audio") { if (isMonitoring && data.payload) { playBotAudioChunk(data.payload); } return; }
      if (data.type === "client_audio") { if (isMonitoring && data.payload) { playClientAudioChunk(data.payload); } return; }
      const log = data.message || event.data;
      console.log("Log recibido:", log);
      if (log.includes("Recibido evento de interrupción")) { clearAudioQueues(); }
      logsElement.innerHTML += log + '\n';
      setTimeout(() => { logsElement.scrollTop = logsElement.scrollHeight; }, 10);
      
      const chatBox = document.getElementById('chatBox');
      if (log.includes("[LOG] [Twilio] Respuesta del agente:")) {
        const messageText = log.replace("[LOG] [Twilio] Respuesta del agente:", "").trim();
        const messageDiv = document.createElement("div");
        messageDiv.className = "chat-message server bg-gray-200 p-2 rounded-lg mb-2 max-w-[70%]";
        messageDiv.textContent = messageText;
        chatBox.appendChild(messageDiv);
        chatBox.scrollTop = chatBox.scrollHeight;
        document.getElementById('statusIndicator').classList.replace('bg-red-500', 'bg-green-500');
        document.getElementById('statusText').textContent = 'Conectado';
      } else if (log.includes("[LOG] [Twilio] Transcripción del usuario:")) {
        const messageText = log.replace("[LOG] [Twilio] Transcripción del usuario:", "").trim();
        const messageDiv = document.createElement("div");
        messageDiv.className = "chat-message client bg-green-100 p-2 rounded-lg mb-2 max-w-[70%] ml-auto";
        messageDiv.textContent = messageText;
        chatBox.appendChild(messageDiv);
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    };

    logsWs.onclose = () => {
      logsElement.innerHTML += '[Conexión a logs cerrada]\n';
      document.getElementById('statusIndicator').classList.replace('bg-green-500', 'bg-red-500');
      document.getElementById('statusText').textContent = 'Sin conexión';
    };
  </script>
</body>
</html>
